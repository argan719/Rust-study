fn main() {
    // let x = 5;
    // println!("The value of x is: {x}");
    // x = 6;
    // println!("The value of x is: {x}");
    // 에러 발생: 불변 변수 'x'에 두 번 값을 할당할 수 없다.


    // 변수명 앞에 mut을 붙여서 가변으로 만들어 줄 수 있다.
    let mut x = 5;
    println!("The value of x is: {x}:");
    x = 6;
    println!("The vlaue of x is: {x}");



    // << 상수 >>
    // 상수는 항상 불변. let이 아닌 const로 선언. 항상 자료형 명시해야 한다.
    // 상수 선언 예제
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;



    // << 섀도잉 >>
    // 새 변수를 이전 변수명과 같은 이름으로 선언할 수 있다.
    // 섀도잉 예제
    let y = 5;

    let y = y + 1;  // let y를 반복해 새로운 변수 y를 만들고 원래 값에 1을 더한 값을 대인해서 y의 값은 6이 된다.

    {
        let y = y * 2;  // 이전 값에 2를 곱해 y에 할당해서 y의 최종값은 12가 된다.
        println!("The value of x in the inner scope is: {y}");
    }
    // 이 중괄호(스코프)가 끝나면 섀도잉이 끝나서 y는 12가 아닌 다시 6이 된다.

    println!("The value of x is: {y}");  // 6


    // let을 사용하면, 값을 변형하면서 변형이 완료된 후에는 불변으로 유지할 수 있다.
    // let을 사용하면, 새로운 변수를 만드는 것이기 때문에 같은 변수명으로 다른 타입의 값을 저장할 수 있다.
}





fn main(){
    // 부동 소수점 타입
    let x = 2.0;  // f64  (기본 타입은 f64)
    let y: f32 = 3.0;  // f32

    // 문자 타입
    let c = 'z';
    let z: char = 'Z';  // 명시적인 타입 어노테이션
    let heart_eyed_cat = '😻';



    // 복합 타입
    // 복합 타입은 여러 값을 하나의 타입으로 묶을 수 있다. 러스트에는 튜플과 배열, 두 가지 존재.

    // << 튜플 타입 >>
    // 여러 값을 묶어 하나의 복합 타입으로 만듦. 튜플은 고정된 길이를 가지므로, 한 번 선언되면 그 크기를 늘리거나 줄일 수 없다.
    // 괄호 안에 쉼표로 구분하여 값들의 목록을 작성하면 튜플을 만들 수 있다. 
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // 튜플은 하나의 복합 요소로 취급되므로 변수 tup은 튜플 전체가 바인딩 된다.
    // 튜플로부터 개별 값을 얻어 오려면 아래와 같이 패턴 매칭을 하여 튜플 값을 해체해서 사용할 수 있다. 
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;   // tup을 세 개의 분리된 변수 x,y,z 로 바꾼다. (=destructuring)
    println!("The value of y is: {y}");


    // .을 이용하여 인덱스를 쓰는 방식으로도 튜플 요소에 접근 가능.
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;
    // 튜플 x를 만들고 인덱스를 사용하여 이 튜플의 각 요소에 접근.




    // << 배열 타입 >>
    // 튜플과는 달리 배열의 모든 요소는 모두 같은 타입이여야 한다. 러스트의 배열은 고정된 길이를 갖는다.
    // [ ] 안에 쉼표로 구분한 값들을 나열해서 배열을 만들 수 있다.
    let a = [1, 2, 3, 4, 5];
    let months = ["January", "February", "March", "April", "May", "June", "July"];
    // 러스트에도 벡터 있음.

    // 대괄호 안에 요소의 타입을 쓰고 세미콜론을 쓴 뒤 요소의 개수를 적는 식으로 배열의 타입을 작성할 수도 있다.
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    // i32는 각 요소의 타입, 5는 배열의 길이.

    // 대괄호 안에 초깃값과 세미콜론을 쓴 다음 배열의 길이를 적는 방식을 사용하여 모든 요소가 동일한 값으로 채워진 배열 선언 가능
    let a = [3; 5];
    // a라는 배열은 모두 3으로 채워진 5개의 요소를 갖게 됨. <=> let a = [3, 3, 3, 3, 3];


    // 배열에 접근하기
    let a = [1, 2, 3, 4, 5];

    let first = a[0];   // 1
    let second = a[1];  // 2

}